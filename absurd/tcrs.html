<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/Documents/Code/simpleinfer/src/typesafe/type_checker.rs.html</title>
<meta name="Generator" content="Vim/8.0">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="rust">
<meta name="settings" content="use_css,no_foldcolumn,expand_tabs,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="onedark">
<style>
<!--
pre { font-family: monospace; color: #abb2bf; background-color: #282c34; }
body { font-family: monospace; color: #abb2bf; background-color: #282c34; }
* { font-size: 1em; }
.String { color: #98c379; }
.Operator { color: #c678dd; }
.Keyword { color: #e06c75; }
.Include { color: #61afef; }
.PreProc { color: #e5c07b; }
.Define { color: #c678dd; }
.Macro { color: #c678dd; }
.StorageClass { color: #e5c07b; }
.Constant { color: #56b6c2; }
.Number { color: #d19a66; }
.Function { color: #61afef; }
.Identifier { color: #e06c75; }
.Conditional { color: #c678dd; }
.Type { color: #e5c07b; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Keyword">use</span> <span class="Include">crate</span>::<span class="Include">expr</span>::{Expression, Id};
<span class="Keyword">use</span> <span class="Include">crate</span>::<span class="Include">typesafe</span>::<span class="Include">substitution</span>::Substitution;
<span class="Keyword">use</span> <span class="Include">crate</span>::<span class="Include">typesafe</span>::<span class="Include">type_environment</span>::TypeEnvironment;
<span class="Keyword">use</span> <span class="Include">crate</span>::<span class="Include">typesafe</span>::<span class="Include">types</span>::Type;
<span class="Keyword">use</span> <span class="Include">crate</span>::<span class="Include">typesafe</span>::<span class="Include">types</span>::<span class="Include">Type</span>::{Bool, Function, Int, Unknown};

<span class="Macro">macro_rules!</span> propagate_res_res {
    (<span class="Define">$cl</span>: expr) <span class="Operator">=&gt;</span> {
        <span class="Conditional">match</span> <span class="Define">$cl</span> {
            <span class="Constant">Err</span>(e) <span class="Operator">=&gt;</span> <span class="Keyword">return</span> <span class="Constant">Err</span>(e),
            <span class="Constant">Ok</span>(e) <span class="Operator">=&gt;</span> e,
        }
    };
}

<span class="Macro">macro_rules!</span> propagate_opt_res {
    (<span class="Define">$cl</span>: expr) <span class="Operator">=&gt;</span> {
        <span class="Conditional">match</span> (<span class="Define">$cl</span>) {
            <span class="Constant">Some</span>(e) <span class="Operator">=&gt;</span> <span class="Keyword">return</span> <span class="Constant">Err</span>(e),
            _ <span class="Operator">=&gt;</span> (),
        }
    };
}

<span class="Macro">macro_rules!</span> propagate_opt_opt {
    (<span class="Define">$cl</span>: expr) <span class="Operator">=&gt;</span> {
        <span class="Conditional">match</span> (<span class="Define">$cl</span>) {
            <span class="Constant">Some</span>(e) <span class="Operator">=&gt;</span> <span class="Keyword">return</span> <span class="Constant">Some</span>(e),
            _ <span class="Operator">=&gt;</span> (),
        }
    };
}

<span class="PreProc">#[</span><span class="PreProc">derive(</span><span class="Type">Debug</span><span class="PreProc">, </span><span class="Type">PartialEq</span><span class="PreProc">)</span><span class="PreProc">]</span>
<span class="Keyword">pub</span> <span class="Keyword">enum</span> <span class="Identifier">TypeError</span> {
    <span class="Function">Unify</span>(Type, Type),
    <span class="Function">Recursion</span>(<span class="Type">u32</span>, Type),
    <span class="Function">Unknown</span>(Id),
}

<span class="Keyword">pub</span> <span class="Keyword">struct</span> <span class="Identifier">TypeChecker</span> {
    unknown_suppl: <span class="Type">u32</span>,
    substitution: Substitution,
}

<span class="Keyword">impl</span> TypeChecker {
    <span class="Keyword">pub</span> <span class="Keyword">fn</span> <span class="Function">new</span>() <span class="Operator">-&gt;</span> <span class="Type">Self</span> {
        <span class="Type">Self</span> {
            unknown_suppl: <span class="Number">0</span>,
            substitution: <span class="Include">Substitution</span>::<span class="Function">new</span>(),
        }
    }

    <span class="Keyword">fn</span> <span class="Function">substitute</span>(<span class="StorageClass">&amp;</span><span class="Constant">self</span>, ty: Type) <span class="Operator">-&gt;</span> Type {
        <span class="Constant">self</span>.substitution.<span class="Function">apply</span>(ty)
    }

    <span class="Keyword">fn</span> <span class="Function">add_substitution</span>(<span class="StorageClass">&amp;</span><span class="StorageClass">mut</span> <span class="Constant">self</span>, id: <span class="Type">u32</span>, ty: Type) {
        <span class="Constant">self</span>.substitution.<span class="Function">set</span>(id, ty)
    }

    <span class="Keyword">pub</span> <span class="Keyword">fn</span> <span class="Function">clear</span>(<span class="StorageClass">&amp;</span><span class="StorageClass">mut</span> <span class="Constant">self</span>) {
        <span class="Constant">self</span>.unknown_suppl <span class="Operator">=</span> <span class="Number">0</span>;
        <span class="Constant">self</span>.substitution.<span class="Function">clear</span>();
    }

    <span class="Keyword">fn</span> <span class="Function">fresh_unknown</span>(<span class="StorageClass">&amp;</span><span class="StorageClass">mut</span> <span class="Constant">self</span>) <span class="Operator">-&gt;</span> Type {
        <span class="Keyword">let</span> unknown <span class="Operator">=</span> <span class="Include">Type</span>::<span class="Function">Unknown</span>(<span class="Constant">self</span>.unknown_suppl);
        <span class="Constant">self</span>.unknown_suppl <span class="Operator">+=</span> <span class="Number">1</span>;
        <span class="Keyword">return</span> unknown;
    }

    <span class="Keyword">pub</span> <span class="Keyword">fn</span> <span class="Function">infer</span>(<span class="StorageClass">&amp;</span><span class="StorageClass">mut</span> <span class="Constant">self</span>, expr: <span class="StorageClass">&amp;</span>Expression) <span class="Operator">-&gt;</span> <span class="Type">Result</span><span class="Operator">&lt;</span>Type, TypeError<span class="Operator">&gt;</span> {
        <span class="Keyword">let</span> infer <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(expr, <span class="StorageClass">&amp;</span><span class="Include">TypeEnvironment</span>::<span class="Function">new</span>()));
        <span class="Macro">println!</span>(<span class="String">&quot;{:?}&quot;</span>, <span class="Constant">self</span>.substitution);
        <span class="Keyword">let</span> subst <span class="Operator">=</span> <span class="Constant">self</span>.<span class="Function">substitute</span>(infer);
        <span class="Constant">Ok</span>(subst)
    }

    <span class="Keyword">fn</span> <span class="Function">infer_env</span>(<span class="StorageClass">&amp;</span><span class="StorageClass">mut</span> <span class="Constant">self</span>, expr: <span class="StorageClass">&amp;</span>Expression, env: <span class="StorageClass">&amp;</span>TypeEnvironment) <span class="Operator">-&gt;</span> <span class="Type">Result</span><span class="Operator">&lt;</span>Type, TypeError<span class="Operator">&gt;</span> {
        <span class="Conditional">match</span> expr {
            <span class="Include">Expression</span>::<span class="Function">IntLiteral</span>(_) <span class="Operator">=&gt;</span> <span class="Constant">Ok</span>(Int),
            <span class="Include">Expression</span>::<span class="Function">BoolLiteral</span>(_) <span class="Operator">=&gt;</span> <span class="Constant">Ok</span>(Bool),
            <span class="Include">Expression</span>::<span class="Function">StringLiteral</span>(_) <span class="Operator">=&gt;</span> <span class="Constant">Ok</span>(<span class="Include">Type</span>::<span class="Type">String</span>),
            <span class="Include">Expression</span>::<span class="Function">Variable</span>(id) <span class="Operator">=&gt;</span> env.<span class="Function">find</span>(id),
            <span class="Include">Expression</span>::<span class="Function">Let</span>(id, expr, body) <span class="Operator">=&gt;</span> {
                <span class="Keyword">let</span> ty_expr <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(expr, env));
                <span class="Keyword">let</span> body_env <span class="Operator">=</span> env.<span class="Function">extend</span>(id.<span class="Function">clone</span>(), ty_expr);
                <span class="Constant">self</span>.<span class="Function">infer_env</span>(body, <span class="StorageClass">&amp;</span>body_env)
            }
            <span class="Include">Expression</span>::<span class="Function">Lambda</span>(arg, body) <span class="Operator">=&gt;</span> {
                <span class="Keyword">let</span> ty_arg <span class="Operator">=</span> <span class="Constant">self</span>.<span class="Function">fresh_unknown</span>();
                <span class="Keyword">let</span> body_env <span class="Operator">=</span> env.<span class="Function">extend</span>(arg.<span class="Function">clone</span>(), ty_arg.<span class="Function">clone</span>());
                <span class="Keyword">let</span> ty_res <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(body, <span class="StorageClass">&amp;</span>body_env));
                <span class="Constant">Ok</span>(<span class="Function">Function</span>(<span class="Type">Box</span>::<span class="Function">new</span>(ty_arg), <span class="Type">Box</span>::<span class="Function">new</span>(ty_res)))
            }
            <span class="Include">Expression</span>::<span class="Function">Application</span>(lambda, argument) <span class="Operator">=&gt;</span> {
                <span class="Keyword">let</span> ty_argument <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(argument, env));
                <span class="Keyword">let</span> ty_lambda <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(lambda, env));
                <span class="Keyword">let</span> ty_return <span class="Operator">=</span> <span class="Constant">self</span>.<span class="Function">fresh_unknown</span>();

                <span class="Keyword">let</span> ty_fun <span class="Operator">=</span> <span class="Function">Function</span>(<span class="Type">Box</span>::<span class="Function">from</span>(ty_argument), <span class="Type">Box</span>::<span class="Function">from</span>(ty_return.<span class="Function">clone</span>()));
                <span class="Macro">propagate_opt_res!</span>(<span class="Constant">self</span>.<span class="Function">unify</span>(ty_lambda, ty_fun));
                <span class="Constant">Ok</span>(ty_return)
            }
            <span class="Include">Expression</span>::<span class="Function">If</span>(cond, then_case, else_cae) <span class="Operator">=&gt;</span> {
                <span class="Keyword">let</span> ty_cond <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(cond, env));
                <span class="Keyword">let</span> ty_then <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(then_case, env));
                <span class="Keyword">let</span> ty_else <span class="Operator">=</span> <span class="Macro">propagate_res_res!</span>(<span class="Constant">self</span>.<span class="Function">infer_env</span>(else_cae, env));

                <span class="Macro">propagate_opt_res!</span>(<span class="Constant">self</span>.<span class="Function">unify</span>(ty_cond, Bool));
                <span class="Macro">propagate_opt_res!</span>(<span class="Constant">self</span>.<span class="Function">unify</span>(ty_then.<span class="Function">clone</span>(), ty_else));
                <span class="Constant">Ok</span>(ty_then)
            }
        }
    }

    <span class="Keyword">fn</span> <span class="Function">unify</span>(<span class="StorageClass">&amp;</span><span class="StorageClass">mut</span> <span class="Constant">self</span>, ty1: Type, ty2: Type) <span class="Operator">-&gt;</span> <span class="Type">Option</span><span class="Operator">&lt;</span>TypeError<span class="Operator">&gt;</span> {
        <span class="Keyword">let</span> ty1 <span class="Operator">=</span> <span class="Constant">self</span>.<span class="Function">substitute</span>(ty1);
        <span class="Keyword">let</span> ty2 <span class="Operator">=</span> <span class="Constant">self</span>.<span class="Function">substitute</span>(ty2);
        <span class="Conditional">match</span> (ty1, ty2) {
            (ty1, ty2) <span class="Conditional">if</span> ty1 <span class="Operator">==</span> ty2 <span class="Operator">=&gt;</span> <span class="Constant">None</span>,
            (<span class="Function">Function</span>(arg1, ret1), <span class="Function">Function</span>(arg2, ret2)) <span class="Operator">=&gt;</span> {
                <span class="Macro">propagate_opt_opt!</span>(<span class="Constant">self</span>.<span class="Function">unify</span>(<span class="StorageClass">*</span>arg1, <span class="StorageClass">*</span>arg2));
                <span class="Macro">propagate_opt_opt!</span>(<span class="Constant">self</span>.<span class="Function">unify</span>(<span class="StorageClass">*</span>ret1, <span class="StorageClass">*</span>ret2));
                <span class="Constant">None</span>
            }
            (<span class="Function">Unknown</span>(id), ty2) <span class="Operator">=&gt;</span> {
                <span class="Conditional">if</span> ty2.<span class="Function">unknowns</span>().<span class="Function">contains</span>(<span class="StorageClass">&amp;</span>id) {
                    <span class="Constant">Some</span>(<span class="Include">TypeError</span>::<span class="Function">Recursion</span>(id, ty2))
                } <span class="Conditional">else</span> {
                    <span class="Constant">self</span>.<span class="Function">add_substitution</span>(id, ty2);
                    <span class="Constant">None</span>
                }
            }
            (ty1, <span class="Function">Unknown</span>(id)) <span class="Operator">=&gt;</span> {
                <span class="Conditional">if</span> ty1.<span class="Function">unknowns</span>().<span class="Function">contains</span>(<span class="StorageClass">&amp;</span>id) {
                    <span class="Constant">Some</span>(<span class="Include">TypeError</span>::<span class="Function">Recursion</span>(id, ty1))
                } <span class="Conditional">else</span> {
                    <span class="Constant">self</span>.<span class="Function">add_substitution</span>(id, ty1);
                    <span class="Constant">None</span>
                }
            }
            (ty1, ty2) <span class="Operator">=&gt;</span> <span class="Constant">Some</span>(<span class="Include">TypeError</span>::<span class="Function">Unify</span>(ty1, ty2)),
        }
    }
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
